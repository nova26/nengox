import numpy as np
rng = np.random.RandomState(0)
import nengo_loihi
nengo_loihi.set_defaults()

def jitter_time(n, t, jitter, rng, dtype="<u4"):
    assert jitter >= 0
    assert t - jitter >= 0
    tt = (t - jitter) * np.ones(n, dtype=dtype)
    if jitter > 0:
        tt += rng.randint(0, 2 * jitter + 1, size=tt.shape, dtype=dtype)
    return tt


def create_data():
    # the height and width of the DVS sensor
    dvs_height = 180
    dvs_width = 240

    # our timestep in microseconds (Î¼s)
    dt_us = 1000

    # the maximum amount by which to jitter spikes around the timestep (in microseconds)
    t_jitter_us = 100

    assert t_jitter_us < dt_us // 2

    # the length of time to generate data for, in seconds and in microseconds
    t_length = 1.0
    t_length_us = int(1e6 * t_length)

    # the maximum rate of input spikes (per pixel)
    max_rate = 10
    max_prob = max_rate * 1e-6 * dt_us

    # the period of the sine wave, in pixels
    period = 120

    # these functions control the angle (theta) and phase of the sine wave over time
    theta_fn = lambda t: 1
    phase_fn = lambda t: 10 * t

    X, Y = np.meshgrid(np.linspace(-1, 1, dvs_width), np.linspace(-1, 1, dvs_height))

    events = []
    for t_us in range(dt_us, t_length_us + 1, dt_us):
        t = t_us * 1e-6
        theta = theta_fn(t)
        phase = phase_fn(t)

        X1 = np.cos(theta) * X + np.sin(theta) * Y

        x = np.linspace(-1.5, 1.5, 50)
        prob = np.sin((np.pi * dvs_height / period) * x + phase) * max_prob
        prob = np.interp(X1, x, prob)

        u = rng.rand(*prob.shape)
        s_on = u < prob
        s_off = u < -prob

        y, x = s_off.nonzero()
        tt = jitter_time(len(x), t_us, t_jitter_us, rng, dtype="<u4")
        events.append((tt, 0, x, y))

        y, x = s_on.nonzero()
        tt = jitter_time(len(x), t_us, t_jitter_us, rng, dtype="<u4")
        events.append((tt, 1, x, y))

    dvs_events = nengo_loihi.dvs.DVSEvents()
    dvs_events.init_events(n_events=sum(len(xx) for _, _, xx, _ in events))

    i = 0
    for tt, p, xx, yy in events:
        ee = dvs_events.events[i: i + len(xx)]
        ee["t"] = tt
        ee["p"] = p
        ee["x"] = xx
        ee["y"] = yy
        i += len(xx)

    events_file_name = "dvs-from-file-events.events"
    dvs_events.write_file(events_file_name)
    print("Wrote %r" % events_file_name)


import nengo
import nengo_loihi
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import ArtistAnimation

# Use the default configuration for NengoLoihi
nengo_loihi.set_defaults()

# Load the event data from the file generated by `create_data()`
events_file_name = "dvs-from-file-events.events"
dvs_events = nengo_loihi.dvs.DVSEvents.from_file(events_file_name)

# Simulation time step in seconds
dt = 0.001  # 1 ms time step

# Parameters for DVS
dvs_height = 180
dvs_width = 240


# Preprocess the DVS events to generate input spikes
def preprocess_dvs_events(dvs_events, dvs_height, dvs_width, dt):
    t_data = dvs_events.events["t"] * 1e-6  # Convert time to seconds
    p_data = dvs_events.events["p"]
    x_data = dvs_events.events["x"]
    y_data = dvs_events.events["y"]

    num_time_steps = int(np.ceil(t_data.max() / dt))

    # Create a time-binned spike array
    spikes = np.zeros((num_time_steps, dvs_height, dvs_width), dtype=np.float32)

    # Bin the events into time steps
    time_indices = np.floor(t_data / dt).astype(int)
    for i in range(len(t_data)):
        x, y = x_data[i], y_data[i]
        spikes[time_indices[i], y, x] = 1 if p_data[i] == 1 else -1  # +1 for ON, -1 for OFF events

    return spikes, num_time_steps


# Preprocess the events to get spike data
spike_data, num_time_steps = preprocess_dvs_events(dvs_events, dvs_height, dvs_width, dt)

# Create a Nengo model
model = nengo.Network()
with model:
    # Input node that reads precomputed spike data
    def dvs_input(t):
        time_index = int(np.floor(t / dt))
        if time_index < spike_data.shape[0]:
            return spike_data[time_index].ravel()
        else:
            return np.zeros(dvs_height * dvs_width)


    # Create input node for the DVS data
    dvs_node = nengo.Node(output=dvs_input, size_out=dvs_height * dvs_width)

    # Create a spiking neuron ensemble
    neuron_ensemble = nengo.Ensemble(
        n_neurons=dvs_height * dvs_width,
        dimensions=1,
        neuron_type=nengo.SpikingRectifiedLinear(),
    )

    # Connect the DVS input node to the ensemble of neurons
    nengo.Connection(dvs_node, neuron_ensemble.neurons)

    # Probe the ensemble's spikes
    spike_probe = nengo.Probe(neuron_ensemble.neurons)

# Simulate the network
t_length = num_time_steps * dt  # Total simulation time
with nengo_loihi.Simulator(model, dt=dt) as sim:
    sim.run(t_length)

# Post-process the simulation data
sim_t = sim.trange()
shape = (len(sim_t), dvs_height, dvs_width)

# Reshape the spike data to match the 2D pixel grid
output_spikes = sim.data[spike_probe].reshape(shape) * sim.dt  # Multiply by dt to get spike counts

# Visualization parameters
dt_frame = 0.01  # Frame duration in seconds
t_frames = dt_frame * np.arange(int(round(t_length / dt_frame)))

# Create a figure for the animation
fig = plt.figure()
imgs = []

# Generate frames from spike data
for t_frame in t_frames:
    t0 = t_frame
    t1 = t_frame + dt_frame
    m = (sim_t >= t0) & (sim_t < t1)

    # Aggregate spikes over the time window for each frame
    frame_img = output_spikes[m].sum(axis=0)

    # Normalize and display spikes as an image
    img = plt.imshow(frame_img, vmin=0, vmax=np.max(frame_img), cmap="hot", animated=True)
    imgs.append([img])

# Create an animation
ani = ArtistAnimation(fig, imgs, interval=50, blit=True)

# Save the animation as a video using FFmpeg
ani.save("dvs_neuron_output.mp4", writer='ffmpeg')

# Optionally display the animation
# plt.show()

print("Animation saved as dvs_neuron_output.mp4")

